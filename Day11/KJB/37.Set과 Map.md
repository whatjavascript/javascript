# 37. Set과 Map

### 37.1 Set

set 객체는 중복되지 않는 유일한 값들의 집합이다. 배열과 유사하지만 차이점이 있다.

| 구분 | 배열 | set 객체 |
| --- | --- | --- |
| 동일한 값을 중복하여 포함할 수 있다. | ○ | × |
| 요소 순서에 의미가 있다. | ○ | × |
| 인덱스로 요소에 접근할 수 있다. | ○ | × |

set 객체의 특성은 수학적 집합의 특성과 일치하며 set은 이를 구현하기 위한 자료구조라고 볼 수 있다. set을 통해 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.

**37.1.1 Set 객체의 생성**

```jsx
const set = new Set(); // set(0) {}

const set1 = new Set([1, 2, 3, 4]); // Set(3) {1, 2, 3}
const set2 = new Set('hello'); // Set(4) {"h", "e", "l", "o"}

// 배열 중복 요소 제거
const uniq = array => array.filter((v, i, self) => self.indexOf(v) === i);
console.log(uniq([2, 1, 2, 3, 4, 3, 4])); // [2, 1, 3, 4]

// Set을 사용한 배열 중복 요소 제거
const uniq2 = array => [...new Set(array)];
console.log(uniq([2, 1, 2, 3, 4, 3, 4])); // [2, 1, 3, 4]
```

Set 객체는 Set 생성자 함수로 생성, Set 생성자 함수에 인수를 전달하지 않으면 빈 Set 객체가 생성되고 이터러블을 인수로 전달받으면 전달 받은 값을 기본값으로 객체가 생성됨. 중복된 값은 Set 객체에 요소로 저장되지 않아 배열에서 중복된 요소를 제거할 수 있다.

**37.1.2 요소 개수 확인**

```jsx
const { size } = new Set([1, 2, 3, 3]);
console.log(size); // 3

const set = new Set([1, 2, 3]);
console.log(Object.getOwnPropertyDescriptor(Set.prototype, 'size'));
// {set: undefined, enumerable: false, configurable: true, get: f }

/*
	size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티다. 따라서 size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.
 */

set.size = 10; // 무시된다
console.log(set.size); // 3
```

**37.1.3 요소 추가**

```jsx
const set = new Set();

set.add(1);
console.log(set); // Set(1) {1}

set.add(2).add(2)
console.log(set); // Set(2) {1, 2}
```

add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 add 메서드를 호출한 후에 add 메서드를 연속적으로 호출 할 수있다. Set 객체에 중복된 요소의 추가는 허용하지 않아 추가가 무시된다(에러발생x)

```jsx
const set = new Set();

// 일치비교연산자는 NaN을 다르다고 평가하지만 Set 객체는 같다고 평가한다. +0과 -0은 일치비교연산자와 같게 평가하여 중복 추가를 허용하지 않는다

console.log(NaN === NaN); // false
console.log(0 === -0); // true

// NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다
```

set 객체는 객체나 배열과 같이 자바스크립트의 모든 값을 요소로 저장할 수 있다.

**37.1.4 요소 존재 여부 확인**

```jsx
const set = new Set([1, 2, 3]);

console.log(set.has(2)); // true
console.log(set.has(4)); // false
```

**37.1.5 요소 삭제**

```jsx
const set = new Set([1, 2, 3]);

// 삭제할 요소 값을 인수로 전달해야 한다. Set 객체는 순서에 의미가 없기 떄문에 배열과 같이 인덱스를 갖지 않기 떄문이다

set.delete(2); // Set(2) {1, 3};

// 존재하지 않는 Set 객체의 요소를 삭제하면 에러 없이 무시된다
// delete는 불리언 값을 반환한다, 따라서 Set.prototype.add 메서드와 달리 연속적으로 호출할 수 없다
```

**37.1.6 요소 일괄 삭제**

```jsx
const set = new Set([1, 2, 3]);

set.clear();
console.log(set); // Set(0) {}
```

**37.1.7 요소 순회**

객체의 요소를 순회하려면 Set.prototype.forEach 메서드를 사용한다. Array의 forEach와 유사하게 콜백 함수와 forEach 메서드의 콜백 함수 내부에서 this로 사용될 객체(옵션)를 인수로 전달한다. 콜백 함수는 3개의 인수를 전달받는다.

- **첫 번째 인수** : 현재 순회 중인 요소값
- **두 번째 인수** : 현재 순회 중인 요소값
- **세 번째 인수** : 현재 순회 중인 Set 객체 자체

```jsx
const set = new Set([1, 2, 3]);

set.forEach((v, v2, set)) => console.log(v, v2, set));

/* 
1 1 Set(3) {1, 2, 3}
2 2 Set(3) {1, 2, 3}
3 3 Set(3) {1, 2, 3}
*/

// Set 객체는 이터러블로 for ... of 문으로 순회할 수 있으며 스프레드 문법과 배열 디스트럭처링의 대상이 될 수도 있다
```

Set 객체는 요소의 순서에 의미를 갖지 않지만 Set 객체를 순회하는 순서는 요소가 추가된 순서를 따른다. ECMAScript 사양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.

**37.1.8 집합 연산**

Set 객체를 통해 교집합, 합집합, 차집합 등을 구현할 수 있다.

```jsx
// 교집합
Set.prototype.intersection = function (set) {
	const result = new Set();
	for (const value of set) {
		// 2개의 set 요소가 공통되는 요소이면 교집합의 대상
		if (this.has(value)) result.add(value);
	}
	return result;
};
Set.prototype.intersection = function (set) {
	return new Set([...this].filter(v => set.has(v)))
};

// 합집합
Set.prototype.union = function (set) {
	// this(Set 객체)를 복사
	const result = new Set(this);
	for (const value of set) {
		// 합집합은 2개의 Set 객체의 모든 요소로 구성된 집합이다. 중복된 요소는 포함되지 않음
		result.add(value);
	}
	return result;
}
Set.prototype.union = function (set) {
	return new Set([...this, ...set])
};

// 차집합
Set.prototype.difference = function (set) {
	const result = new Set(this);
	for (const value of set) {
		// 차집합은 어느 한쪽 집합에는 있고 다른 한쪽 집합에는 존재하지 않는 요소로 구성된 집합
		result.delete(value);
	}
	return result;
};
Set.prototype.difference = function (set) {
	return new Set([...this].filter(v => !set.has(v)))
};

// 부분 집합과 상위 집합
Set.prototype.isSuperset = function (subset) {
	for (const value of subset) {
		// superset의 모든 요소가 subset의 모든 요소를 포함하는지 확인
		if (!this.has(value)) return false;
	}
};
Set.prototype.isSuperset = function (subset) {
	const supersetArr = [...this];
	return [...subset].every(v => supersetArr.includes(v));
};

const setA = new Set([1, 2, 3, 4]);
const setB = new Set([2, 4]);
```

### 37.2 Map

Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. Map 객체는 객체와 유사하지만 차이점이 있다.

| 구분 | 객체 | Map 객체 |
| --- | --- | --- |
| 키로 사용할 수 있는 값 | 문자열 또는 심벌 값 | 객체를 포함한 모든 값 |
| 이터러블 | × | ○ |
| 요소 개수 확인 | Object.keys(obj).length | map.size |

**37.2.1 Map 객체의 생성**

```jsx
const map = new Map(); // Map(0) {}

const map1 = new Map(['key1', 'value1'], ['key2', 'value2']);
console.log(map1); // Map(2) {"key1" => "value1", "key2" => "value2"}

const map2 = new Map([1, 2]); // TypeError: Iterator value 1 is not an entry object

const map3 = new Map([['key1', 'value1'], ['key1', 'value2']);
console.log(map3); // Map(1) {"key1" => "value2"}
```

Map 생성자 함수에 인수를 전달하지 않으면 빈 Map 객체가 생성됨. Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성. 이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다. 

Map 생성자 함수의 인수로 전달한 이터러블에 중복된 키를 갖는 요소가 존재하면 값이 덮어써진다. 따라서 Map 객체에는 중복된 키를 갖는 요소가 존재할 수 없다.

**37.2.2 요소 개수 확인**

```jsx
const { size } = new Map([['key1', 'value1'], ['key2', 'value2']]); // 2

/*
	size 프로퍼티는 setter 함수 없이 getter 함수만 존재하는 접근자 프로퍼티다. 따라서 size 프로퍼티에 숫자를 할당하여 Map 객체의 요소 개수를 변경할 수 없다.
 */
```

**37.2.3 요소 추가**

- Map.prototype.set

```jsx
const map = new Map();
map.set('key1', 'value1');

// set메서드는 새로운 요소가 추가된 Map 객체를 반횐하므로 set 메서드를 호출한 후에 set 메서드를 연속적으로 호출 할 수 있다.
map.set('key1', 'value1').set('key2', 'value2');
console.log(map); // Map(2) {"key1" => "value1", "key2" => "value2"}
```

Map 객체에 중복된 키를 갖는 요소가 존재할 수 없기 때문에 중복된 키를 갖는 요소를 추가하면 값이 에러없이 덮어씌워진다.

NaN, +0 -0을 같다고 표현하여 중복추가를 허용하지 않는다.

객체는 문자열 또는 심벌 값만 키로 사용할 수 있다. 하지만 Map 객체는 키 타입에 제한이 없다. 따라서 객체를 포함한 모든 값을 키로 사용할 수 있다. Map 객체와 일반 객체의 가장 큰 차이점이다.

**37.2.4 요소 취득**

- Map.prototype.get

```jsx
const map = new Map();

const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

map.set(lee, 'developer').set(kim, 'designer');

console.log(map.get(lee)); // developer
console.log(map.get('key')); // undefined
```

**37.2.5 요소 존재 여부 확인**

- Map.prototype.has 특정 요소의 존재 여부를 나타내는 불리언 값 반환

```jsx
const map = new Map([[lee, 'developer'], [kim, 'designer']]);

console.log(map.has(lee)); // true
console.log(map.has('key')); // false
```

**37.2.6 요소 삭제**

- Map.prototype.delete 삭제 성공 여부를 나타내는 불리언 값 반환

```jsx
map.delete(kim);
console.log(map); // Map(1) { {name: "Lee"} => "developer" }

// 만약 존재하지 않는 키로 Map 객체 요소를 삭제하려 하면 에러 없이 무시된다
map.delete('key2');
console.log(map); // Map(1) {"key1" => "value2"}

// set 메서드와 달리 연속적으로 호출 할 수 없다
map.delete(lee).delete(kim); // TypeError: map.delete(...).delete is not a function
```

**37.2.7 요소 일괄 삭제**

- Map.prototype.clear 언제나 undefined 반환

```jsx
map.clear();
console.log(map); // Map(0) {}
```

**37.2.8 요소 순회**

- Map.prototype.forEach
    
    객체의 요소를 순회하려면 Map.prototype.forEach 메서드를 사용한다. Array의 forEach와 유사하게 콜백 함수와 forEach 메서드의 콜백 함수 내부에서 this로 사용될 객체(옵션)를 인수로 전달한다. 콜백 함수는 3개의 인수를 전달받는다.
    
    - **첫 번째 인수** : 현재 순회 중인 요소값
    - **두 번째 인수** : 현재 순회 중인 요소키
    - **세 번째 인수** : 현재 순회 중인 Map 객체 자체

```jsx
const lee = { name: 'Lee' };
const kim = { name: 'Kim' };

const map = new Map([[lee, 'developer'], [kim, 'designer']]);
map.forEach((v, k, map) => console.log(v, k, map));

/* 
	developer {name: "Lee"} Map(2) {
		{name: "Lee"} => "developer",
		{name: "kim"} => "designer"
	}
	designer {name: "kim"} Map(2) {
		{name: "Lee"} => "developer",
		{name: "kim"} => "designer"
	}
*/
```

Map 객체는 이터러블로 for … of 문으로도 순회 가능하며 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.

```jsx
// Map 객체는 Map.prototype의 Symbol.iterator 메서드를 상속받는 이터러블
console.log(Symbol.iterator in map); // true

// 이터러블인 Map 객체는 for ... of 문으로 순회할 수 있음
for (const entry of map) {
	console.log(entry); // [{name: "Lee"], "developer"] [{name: "kim"}, "designer"]
}

// 이터러블인 Map 객체는 스프레드 문법의 대상이 될 수 있음
console.log([...map]);
// [[{name: "Lee"}, "developer"], [{name: "Kim"}, "designer"]]

// 이터러블인 Map 객체는 배열 디스트럭처링 할당이 대상이 될 수 있음
const [a, b] = map;
console.log(a, b); // [{name: "Lee"}, "developer"] [{name: "Kim"}, "designer"]
```

Map 객체는 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다.

| Map 메서드 | 설명 |
| --- | --- |
| Map.prototype.keys | Map 객체에서 요소키를 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. |
| Map.prototype.values | Map 객체에서 요소값를 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. |
| Map.prototype.entries | Map 객체에서 요소키와 요소값을 값으로 갖는 이터러블이면서 동시에 이터레이터인 객체를 반환한다. |

Map 객체는 요소의 순서에 의미를 갖지 않지만 Map 객체를 순회하는 순서는 요소가 추가된 순서를 따른다. 이는 ECMAScript 사양에 규정되어 있지 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.